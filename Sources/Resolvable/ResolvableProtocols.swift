//
//  ResolvableProtocols.swift
//  Resolvable
//
//  Created by Giorgi Tchelidze on 9/1/25.
//

import Foundation

// MARK: - Core Nested Type Protocols

public protocol ResolverProtocol {
    // These associated types connect back to the main Resolvable protocol
    associatedtype Definition
    associatedtype Instance
    associatedtype Override
    associatedtype Resolved

    // This promises the existence of the main resolve method.
    static func resolve(
        definitions: [Definition],
        overrides: [Override],
        instances: [Instance]
    ) -> [Resolved]
}

public protocol ResolvedProtocol {
    // These associated types allow the Resolved struct to know about its related types.
    associatedtype Source
    associatedtype Override
    associatedtype Instance
    
    /// The property that indicates whether this item originated from a Definition or an Instance.
    var source: Source { get }
    
    /// A method that dispatches the "apply" logic to the correct storage array.
    /// The body of this method, including the `switch` on `source`, will be generated by the macro.
    /// - Parameters:
    ///   - toOverrides: A mutable reference to the overrides array from the backing store.
    ///   - andInstances: A mutable reference to the instances array from the backing store.
    func apply(toOverrides: inout [Override], andInstances: inout [Instance])
    
    /// A method that dispatches the "remove" logic.
    /// This handles the different behaviors for removing a definition-based vs. instance-based item.
    func remove(fromOverrides: inout [Override], andInstances: inout [Instance])
}

public protocol OverrideProtocol {
    /// The property that links an override back to its definition.
    var definitionID: UUID { get }
}

public protocol UpdatableFromResolved {
    associatedtype ResolvedType
    /// Updates the instance/override in-place from a resolved model.
    mutating func update(from resolved: ResolvedType)
}

public protocol CreatableFromResolved {
    associatedtype ResolvedType
    /// Creates a new override from a resolved model.
    init(from resolved: ResolvedType)
}


// MARK: - The Master Resolvable Protocol (Fully Constrained)

public protocol Resolvable {
    // Define all the nested types we expect to exist and the protocols they must conform to.
    
    associatedtype Definition: Identifiable & Codable & Hashable where Definition.ID == UUID
    
    associatedtype Instance: Identifiable & Codable & Hashable & UpdatableFromResolved where
        Instance.ResolvedType == Resolved
        
    associatedtype Override: Identifiable & Codable & Hashable & OverrideProtocol & UpdatableFromResolved & CreatableFromResolved where
        Override.ResolvedType == Resolved
        
    // The 'Resolved' type now has a more detailed contract, promising it can handle updates.
    associatedtype Resolved: Identifiable & ResolvedProtocol where
        Resolved.ID == UUID,
        Resolved.Source == Source,
        Resolved.Override == Override,
        Resolved.Instance == Instance
        
    associatedtype Resolver: ResolverProtocol where
        Resolver.Definition == Definition,
        Resolver.Instance == Instance,
        Resolver.Override == Override,
        Resolver.Resolved == Resolved
        
    associatedtype Source: Hashable

    // The main struct (e.g., Property) doesn't need to do anything itself;
    // this protocol just ensures the nested types exist and have the right capabilities.
}
