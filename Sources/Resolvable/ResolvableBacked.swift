//
//  ResolvableBacked.swift
//  CircuitPro
//
//  Created by Giorgi Tchelidze on 9/1/25.
//

import Foundation

/// A protocol for container types (like `ComponentInstance`) that store and manage the data
/// for a specific `@Resolvable` model (like `Property`).
///
/// This protocol provides a powerful, generic "engine" for all the common operations:
/// resolving items for display, and applying changes back to the correct storage.
/// It must be adopted by a class (`AnyObject`) to ensure changes modify the original
/// object, not a copy.
public protocol ResolvableBacked: AnyObject {
    /// The specific `@Resolvable` type this object backs (e.g., `Property`, `CircuitText`).
    /// This conformance links the engine to the correct set of generated types.
    associatedtype ResolvableType: Resolvable

    // MARK: - Required Storage Properties
    
    /// Provides the source array of definitions for the resolvable type.
    /// This is often a `get`-only computed property that retrieves definitions from a library or another model object.
    var definitions: [ResolvableType.Definition] { get }

    /// Provides read/write access to the array of overrides stored on this object.
    /// The `set` is required so the engine can add, remove, and update overrides.
    var overrides: [ResolvableType.Override] { get set }

    /// Provides read/write access to the array of ad-hoc instances stored on this object.
    var instances: [ResolvableType.Instance] { get set }
    
    // MARK: - Required Change Notification
    
    /// A required hook to allow this protocol to signal to SwiftUI that a change has occurred.
    /// For a class conforming to `@Observable`, this method can be empty, as the `set`
    /// on the `overrides` and `instances` properties will trigger observation automatically.
    func markAsChanged()
}


// MARK: - Generic Logic (The Engine)
public extension ResolvableBacked {
    
    /// Resolves all definitions, overrides, and instances into a single, display-ready
    /// array of `Resolved` models. This is the primary "read" entry point for UI.
    var resolvedItems: [ResolvableType.Resolved] {
        ResolvableType.Resolver.resolve(
            definitions: definitions,
            overrides: overrides,
            instances: instances
        )
    }

    /// Applies a change from an edited `Resolved` model back to the appropriate storage array.
    ///
    /// This method is now fully generic. It delegates the specific `switch` logic
    /// to the `apply(toOverrides:andInstances:)` method on the `Resolved` item itself,
    /// which is generated by the `@Resolvable` macro.
    /// - Parameter editedItem: The `Resolved` model containing the new desired state.
    func apply(_ editedItem: ResolvableType.Resolved) {
        markAsChanged()
        
        // Delegate the entire operation to the macro-generated method.
        editedItem.apply(toOverrides: &self.overrides, andInstances: &self.instances)
    }

    /// Adds a new, user-created "ad-hoc" instance to this container.
    /// - Parameter newItem: The `Instance` model to add.
    func add(_ newItem: ResolvableType.Instance) {
        markAsChanged()
        instances.append(newItem)
    }

    /// Removes an item based on its resolved source.
    ///
    /// This method is now fully generic. It delegates the specific `switch` logic
    /// to the `remove(fromOverrides:andInstances:)` method on the `Resolved` item itself,
    /// which handles the different behaviors for definition-based vs. instance-based items.
    /// - Parameter itemToRemove: The `Resolved` model representing the item to remove.
    func remove(_ itemToRemove: ResolvableType.Resolved) {
        markAsChanged()
        
        // Delegate the entire operation to the macro-generated method.
        itemToRemove.remove(fromOverrides: &self.overrides, andInstances: &self.instances)
    }
}
